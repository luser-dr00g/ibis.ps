%!
%(../debug.ps/db5.ps)run %currentfile cvx debug


%optionally dump text to stdout while writing
%/show { dup print (\n) print show } bind def
%/ashow { dup print (\n) print ashow } bind def

% essentially the same as level-2 >> operator
% but it is used in an attempt at level-1 compatibility
% but primarily for historical reasons:
% in 2011, xpost did not have >>
%
% mark k1 v1 .. kN vN  dicttomark  dict(N)
/dicttomark { counttomark dup dict begin 2 idiv { def } repeat pop currentdict end } def


% Composite Index  inc/dec  -
% (n.b. userdict is a composite object (a dict), as are arrays and strings)
/inc { 2 copy get 1 add put } def
/dec { 2 copy get 1 sub put } def

% /numeric-variable addend  +=  -
/+= { 1 index load add store } def
/-= { neg += } def
/*= { 1 index load mul store } def


% Stack type is an array where element 0 contains the index of the top of the stack.
% An overflow of the stack will trigger a rangecheck error in `put`.
%
% n  stack  array{n+1}:[0]=0
/stack { 1 add array dup 0 0 put } def
/top { dup 0 get get } def % S  top  a
/spop { dup top exch 0 dec } def % S  spop  a  (S{n}->S'(n-1})
/spush { % S a  spush  -  (S{n}->S'{n+1})
    dup type /stringtype eq { dup length string copy } if
    1 index 0 inc
    1 index 0 get exch put
} def
/sdrop { % S i  sdrop  -  (S{i}->removed)
    %(sdrop:)=
    1 index 0 get      % S i c
    1 index sub %1 sub  % S i c-i-1
    %pstack()=
    dup 0 gt {
        { % S i
            2 copy 2 copy % S i S i S i
            1 add get put % S' i
            1 add         % S i=i+1
        } repeat % S' i
    }{
        pop
    } ifelse
    pop
    0 dec    % S'
} def
% 1 2 3 4 5 6  < array index
% -----------
% a b c d e f 2 sdrop
% a   c d e f  6-2=4 -1=3
% a c d e f
%/t { 6 a b c d e f } cvlit def t 2 sdrop t ==


% Output device is described only by its bounding box.
% As text is set on the page, the upper bound decreases so the box remains invariant.
%
/dev mark
    /size [ clippath pathbbox ]
    /bounds null
dicttomark def % /dev
/savebounds { dev /bounds [ x y X Y ] put } def
/restorebounds { dev /bounds get aload pop setbounds } def
/setbounds { % x y X Y  setbounds  -
    /Y exch def /X exch def /y exch def /x exch def
} def
/setmargin { % pts  setmargin  -
    dev /size get aload pop
    4 index sub 4 1 roll 4 index sub 4 1 roll
    4 index add 4 1 roll 4 index add 4 1 roll
    setbounds pop savebounds
} def

/nextpage { showpage restorebounds eol } def

/kpairs 26 dict def

% (ab) n  kaddpair  -
/kaddpair {
    1 index 1 get  % (ab) n 98
    exch [ 3 1 roll >>  % (ab) <<98 n>>
    exch 0 get  % <<98 n>> 97
    exch kpairs 3 1 roll put
} def

% 97 98  kgetpair  n
/kgetpair {
    kpairs 3 2 roll 2 copy known { % k2 <<>> k1 
        get  % k2 <<>>
        exch 2 copy known { % <<>> k2
            get
        }{
            pop pop 0
        } ifelse
    }{
        pop pop pop 0
    } ifelse
} def

% proc str  kstringwidth  dx dy
/kstringwidth {
    dup stringwidth 3 2 roll           % p x y s
    dup length 1 gt {                  % p x y s
        0 1 2 index length 2 sub       % p x y s 0 1 len(s)-2
        {                              % p x y s i
            2 copy get                 % p x y s i s[i]
            2 index 3 2 roll 1 add get % p x y s s[i] s[i+1]
            gsave 0 0 moveto
            5 index exec
            currentpoint               % p x y s dx dy
            grestore
            4 3 roll add 3 1 roll      % p x y+=dy s dx
            4 3 roll add 3 1 roll      % p x+=dx y s
        } for
    } if                               % p x y s
    pop 3 2 roll pop                   % x y
} def

(ac) 7 kaddpair
(al) 3 kaddpair
(av) -10 kaddpair
(ce) 5 kaddpair
(ch) -3 kaddpair
(cu) -5 kaddpair
(de) -5 kaddpair
(ec) 10 kaddpair
(ed) 5 kaddpair
(el) 10 kaddpair
(em) 5 kaddpair
(ex) -10 kaddpair
(il) -12 kaddpair
(in) -10 kaddpair
(li) -3 kaddpair
(ll) -2 kaddpair
(om) -5 kaddpair
(ou) -10 kaddpair
(re) 7 kaddpair
(ri) 5 kaddpair
(rn) -5 kaddpair
(rp) 5 kaddpair
(te) 5 kaddpair
(ti) 10 kaddpair
(tp) 10 kaddpair
(ul) -5 kaddpair
(ut) -10 kaddpair
(xe) -5 kaddpair
(Al) -15 kaddpair
(An) -10 kaddpair
(Te) -5 kaddpair
(Th) -5 kaddpair
%(a) 0 get (v) 0 get kgetpair =(-----)=

% Text setting
%
/text mark
    /eol {
        updatelead
        /Y lead -=
        /lead leadchange /leadchange lead store store
        %text /spacecount dec
        chopline
        countspaces
        countchars
        /gap { mark X currentpoint pop sub } stopped { cleartomark mark 0 } if exch pop store
        /spaceadjust spacecount 0 ne { gap spacecount div }{ 0 } ifelse store
        /charadjust charcount 0 ne { gap charcount div }{ 0 } ifelse store
        setline
        %(0)=only
        /spacecount 0 store
        y Y lt { x Y moveto }
               { nextpage } ifelse
    }
    /heol { ( ) setword }
    /blank { [ /eol cvx /justify? justify? /store cvx ] cvx /justify? false store exec }
    /fontchange true
    /spacecount 0
    /charcount 0
    /gap 0
    /spaceadjust 0
    /charadjust 0
    /justify? true
    /kerning? true

    % currentline is used as an extendable array of tuples
    %    [  [ (text) <<font>> lead ]*  ]
    /currentline 100 stack

    /countspaces {
        0
        currentline first 0 get 0 exch getinterval {
            0 get
            %( ) eq { 1 add } if
            {
                32 eq { 1 add } if
            } forall
        } forall
        %spacecount =
        %dup =
        /spacecount exch store
    }

    /countchars {
        0
        currentline first 0 get 0 exch getinterval {
            0 get length add
        } forall
        /charcount exch store
    }

    % trim leading/trailing space
    /chopline {
        currentline 0 get 1 ge {
            {
                currentline 1 get 0 get dup ( ) eq exch () eq or not
                {
                    exit
                } if
                %(chopping initial space)=
                %(-)=only
                currentline 1 sdrop
                text /spacecount dec
                currentline 0 get 1 lt {
                    exit
                } if
            } loop
        } if
        currentline 0 get 1 ge {
            {
                currentline top 0 get ( ) ne {
                    exit
                } if
                %(chopping trailing space)=
                %(-)=only
                currentline spop pop
                text /spacecount dec
                currentline 0 get 1 lt {
                    exit
                } if
            } loop
        } if
    }

    % scan currentline and set lead to the max lead from the line
    /updatelead {
        /leadchange lead store
        currentline first 0 get 0 exch getinterval
        {
            2 get dup leadchange gt { /leadchange exch store }{ pop } ifelse
        } forall
        %lead leadchange lt { /lead leadchange /leadchange lead store store } if
        %/lead leadchange store
        /lead leadchange /leadchange lead store store
    }

    % show the text in currentline using associated font(s).
    % clear currentline.
    /setline {
        x Y
        %(setline:)= pstack()=
        moveto

        currentline first 0 get 0 exch getinterval
        %dup == spaceadjust =only( )=only spacecount =
        {
            %pstack()=
            %aload pop
            dup 0 get exch 1 get
            setfont
            kerning? {
                justify? {
                    dup ( ) eq { spaceadjust 0 rmoveto } if
                    spacecount 0 eq {
                        { kgetpair charadjust add 0
                            currentfont /FontMatrix get dtransform rmoveto }
                    }{
                        { 1 index 32 eq { pop pop spaceadjust 0 }{ kgetpair 0 } ifelse
                            currentfont /FontMatrix get dtransform rmoveto }
                    } ifelse
                }{
                    { kgetpair 0 currentfont /FontMatrix get dtransform rmoveto }
                } ifelse
                exch kshow
            }{
                justify? {
                    spacecount 0 eq {
                        show
                    }{
                        spaceadjust 0 32 4 3 roll widthshow
                    } ifelse
                }{
                    show
                } ifelse
            } ifelse
        } forall
        currentline 0 0 put
        %eol
    }

    /addwordtoline {
        dup length string copy
        %dup length 1 add string dup 3 1 roll copy pop  % copy and append space
        %dup dup length 1 sub ( ) putinterval
        %currentpoint pop =
        %(setword:)= pstack()=
        %currentline == flushpage flush(%lineedit)(r)file pop 
        kerning? {
            { kgetpair 0 currentfont /FontMatrix get dtransform rmoveto }
            1 index kstringwidth
        }{
            dup stringwidth
        } ifelse
        %pstack()=
        pop dup currentpoint pop add X ge {
            eol %setline
        } if
        0 rmoveto
        currentfont lead 3 array astore
        currentline exch spush
    }

    % do nothing for initial empty or blank strings.
    % check stringwidth+currentpoint and flush currentline
    % by calling eol (which calls setline) if too long.
    % rmoveto by the stringwidth
    % add word to currentline.
    /setword {
        dup ( ) eq {
            currentline 0 get 0 eq {
                %(-)=only
                text /spacecount dec
                pop
            }{
                currentline top 0 get ( ) eq {
                    %(-)=only
                    text /spacecount dec
                    pop
                }{
                    addwordtoline
                } ifelse
            } ifelse
        }{
            dup () eq {
                pop
            }{
                addwordtoline
            } ifelse
        } ifelse
    }

    % used like show, this is the call for adding text to the output.
    % chops text into words and calls setword on each.
    /settext {
        fontchange {
            fontfam tty 4 mul bold 2 mul add italic add get setfont
            /fontchange false store
        } if
        %show
        /initialspace false store
        ( ){ anchorsearch {/initialspace true store}{ exit } ifelse } loop %strip initial spaces
        initialspace { ( ) setword } if
        ( ) {
            %search exch setword not { exit } if
            search {
                setword 
                { anchorsearch not {exit} if } loop
                %currentline 0 get 0 gt {
                    %(+)=only
                    ( ) dup setword
                    text /spacecount inc
                %} if
            }{
                setword
                %(+)=only
                %( ) setword
                %text /spacecount inc
                exit
            } ifelse
        } loop
    }

    /fontsize 11
    /lead 12
    /setfontfam {
    text /fontfam [ %  -roman- -italic- -bold- -bold-italic- 
        /Palatino-Roman findfont fontsize scalefont
        /Palatino-Italic findfont fontsize scalefont
        /Palatino-Bold findfont fontsize scalefont
        /Palatino-BoldItalic findfont fontsize scalefont
        /Courier findfont fontsize scalefont
        /Courier-Oblique findfont fontsize scalefont
        /Courier-Bold findfont fontsize scalefont
        /Courier-BoldOblique findfont fontsize scalefont
    ] put
    }
    /italic 0
    /bold 0
    /tty 0

dicttomark def % /text


% Manuscript processing
%

% find takes 3 procedures, a string and search-string
% and executes on_a and on_b upon the returned substrings if found
% or the not procedure if not found
/find {               % {not} {on_b} {on_a} (aXb) (X)  find  -
    search {          % n b a (b) (X) (a)
        4 1 roll pop  % n b (a) a (b)
        4 1 roll      % n (b) b (a) a
        5 -1 roll pop % (b) b (a) a
        /exec cvx 5 3 roll % (a) a exec (b) b
        /exec cvx 6 array astore cvx exec
        %exec exec
    }{                   % n b a (a_b)
        4 1 roll pop pop % (a_b) n
        exec
    } ifelse
} def
%{(n)= =}{(b)= =}{(a)= =} (pretextpost) (text) find
%(stack:)= pstack
%quit

%shift a 1-char string off of a larger string
/first { % (abc)  first  (bc) (a)
    dup 1 1 index length 1 sub getinterval exch
    0 1 getinterval
} def

% delimiter pairs
/pairs mark
    ([)(]) (<)(>) (\()(\)) ({)(}) (`)(') (:)(;)
dicttomark def % /pairs

% ([)  rhs  (])
% (q)  rhs  (q)
% (")  rhs  (")
/rhs { pairs exch 2 copy known { get }{ exch pop } ifelse } def

% the nest stack contains unclosed delimiters for nested short-form segments
%   eg. @i{ @b( @t< > ) }
/nest 10 stack def
% {on_a} (])  deferal  {[{on_a} (])] nest exch spush}
% create a save-it-for-later proc
% for the not-found clause of find
/deferal {
    2 array astore
    [ exch /nest cvx /exch cvx /spush cvx ] cvx
} def

% {on_a} ([a]b)  delim  (b)
/delim {
    exch /process cvx exch /exec cvx 3 array astore cvx exch
    first rhs       % on_a (a]b) (])
    3 copy exch pop % on_a (a]b) (]) on_a (]) 
    deferal         % on_a (a]b) (]) not    %not-clause
    {}              % on_a (a]b) (]) not on_b  %on_b clause: leave string on stack
    5 2 roll        % not on_b on_a (a]b) (])
    %(delim)= pstack()=
    find
} def

% ([arg]rem) /name  short  (rem)
/short {
    %(short)= pstack()=
    alt exch get % s d
    dup /ini get exec % s d ?
    exch /fin get % s ? {}
    [ 3 1 roll /exec cvx ] cvx exch % undo s
    delim
} def

% the pending stack contains unclosed environments bracketed by @Begin() @End()
%
/pending 10 stack def

% (name)  checkpending  -
/checkpending {
    %(checking pending stack)= pending ==
    {
        pending 0 get -1 1 {  % (name) i
            %pstack()=
            pending 1 index get  % (name) i []
            0 get 2 index
            %pstack()=
            eq {  % (name) i
                %pstack()=
                stop
            } if
            pop
        } for
    } stopped {  % (name) i
        pending 1 index get 1 get  % (name) i fin-arg
        3 2 roll alt exch get /fin get exec  % i
        pending exch sdrop
    }{ Err:symbol-not-in-pending-stack } ifelse
} def

% perform the @Begin() action for an enviroment
% ([name]rem)  long  (rem)
/long {
    first rhs          % (name]rem) (])
    {Err:long-form-arg-cannot-span-lines}
    {}
    {
        %pstack()=
        dup length string copy
        dup alt exch get /ini get exec
        2 array astore pending exch
        %pstack()=
        spush
        %pending ==
    }
    5 3 roll  % {} {} {} (name]rem) (])
    find
} def

% perform the @End() action for an environment
% ([name]rem)  long-end  (rem)
/long-end {
    first rhs   % (name]rem) (])
    {Err:long-form-arg-cannot-span-lines}
    {}
    {checkpending} %search pending stack and remove match
    5 3 roll  % {} {} {} (name]rem) (])
    find
} def

% long-form commands to enter/leave an environment
/Begin { long } def
/End { long-end } def

% execute the first token from the string and process the remainder
% str  execute  -
/execute { token { exec process }{ BAD_COMMAND } ifelse } def

% the "at" sign indicates the start of an embedded command
/sigil <40> def

% scan argument string for the sigil and execute command after processing prefix
/command {
    {settext} {execute} {settext} 4 3 roll
    sigil find
} def

% scan string for embedded @commands
% and call settext for other text.
/process { % str  process  -
    %(process:)= pstack()=
    dup length 0 eq {
        pop
        %blank
    }{
        nest 0 get 0 gt {
            {command} {process} nest top aload pop % str {!} {B} {A} (X)
            exch [ exch   % str {!} {B} (X) [ {A}
                nest exch /spop cvx exch /pop cvx exch %/process cvx exch
                    /exec cvx 
            ] cvx exch  % str {!} {B} {A}' (X)
            5 4 roll exch % {!} {B} {A} str (X)
            find
        %    {process}{process} nest top aload pop  % {!} {B} {A} (X)
        %    exch [
        %        %{nest spop pop process {defered "on_a"} exec}
        %        exch nest exch /spop cvx exch /pop cvx exch /process cvx exch /exec cvx
        %        ] cvx exch % {!} {B} {A}' (X)
        %    5 4 roll exch % {!} {B} {A} str (X)
        %    find
        }{
            command
        } ifelse
    } ifelse
} def


/src null def        % input file
/buf 200 string def  % line buffer
/exitflag false def

% call process on each line
%
/ibis { % file|string  ibis  -
    dup type /stringtype eq { (r) file } if
    dup type /filetype ne { NOT_A_FILE } if
    /src exch def

    %pstack()=
    {
        src buf readline {
            dup length 0 eq { blank } if
            %dup dup length 1 sub get = quit
            process
            heol
        }{
            %process
            exit
        }ifelse
        heol
        exitflag { exit } if
    } loop

    eol %setline
    showpage
} def

% @@ define the at-sign as a command to print itself
sigil { sigil settext } def


%alterations, aka environments
/alt 20 dict def

% install an environment in the alterations dict
% name dict  newalter  -
%
% dict should contain 2 procs
% -  ini  ?
% ?  fin  -
% where ini returns an object that should be
% passed to fin
/newalter {
    %install in alt dict
    2 copy alt 3 1 roll put
    %create short-form procedure
    pop [ 1 index /short cvx ] cvx def
} def

/updatefont { /fontchange true store } def

/r mark
    /ini { tty 4 mul bold 2 mul italic add add
        /bold 0 store
        /italic 0 store
        /tty 0 store
        updatefont }
    /fin { dup 2 mod /italic exch store
        2 idiv dup 2 mod /bold exch store
        2 idiv /tty exch store
        updatefont }
dicttomark newalter

/i mark
    /ini { italic /italic 1 store updatefont }
    /fin { /italic exch store updatefont }
dicttomark newalter

/b mark
    /ini { bold /bold 1 store updatefont }
    /fin { /bold exch store updatefont }
dicttomark newalter

/t mark
    /ini { tty /tty 1 store updatefont }
    /fin { /tty exch store updatefont }
dicttomark newalter

/default {
    text begin
    setfontfam
    72 setmargin
} def

/bye {/exitflag true def} def

% print manual only if /manual is defined (eg. `gs -dmanual ibis.ps`)
% uncomment this line to enable this, which allows running ibis.ps on other files
% for ease of development, the source is maintained in this form to enable fast
% testing of changes. While the manual is being developed (in parallel), it also
% serves as an example and testbed.
%/manual where { pop }{ currentfile flushfile } ifelse 

%/i load == quit
%stepon
%traceon

default
%currentfile /ibis load debug
currentfile ibis
Text is passed to the output.
Beginning to implement filled paragraphs.

There are various ways of executing a command to change
a section of text. All commands are introduced by the @@  character,
known internally as the "sigil".

The simple command @@ i for italics, can use the short form 
with various sets of delimiters.

    @@ i[italics] produces @{/tab currentpoint pop def}@i[italics]

    @@ i(italics) @{tab currentpoint exch pop moveto}@i(italics)

    @@ i<italics> @{tab currentpoint exch pop moveto}@i<italics>

    @@ i{italics} @{tab currentpoint exch pop moveto}@i{italics}

    @@ i `italics' @{tab currentpoint exch pop moveto}@i `italics'

    @@ i :italics; @{tab currentpoint exch pop moveto}@i :italics;

These last two require an extra space after the command name since
the backquote and colon are not postscript delimiters.

Incidentally, since the command name is scanned with 'token' and
executed with 'exec', it can even be a postscript procedure.
@{/oldfont currentfont def}

    @@ {/Courier 11 selectfont}text in Courier

    @{/Courier 11 selectfont}text in Courier

@{oldfont setfont}
Only "short-form" commands take a delimited argument. 
The @@ {arbitrary ps code} commands are not "short-form", 
and do not take an argument but apply directly to the current state.
But they do receive the remaining portion of the line as a string,
so a custom command may consume data from the string and yield the
remainder to be printed (it should leave a string on the stack).

Now with @b[bold].

I finally remembered what "deferal" was all about. So let's 
see if it works. It should allow bracketed commands to span
multiple lines. Like so @i[ This sentence should be all italics
despite spanning lines, in a line-oriented scanning routine. ]
And back to normal.

Long-form uses the same command names, but it is now the @i{argument}
to the @@ Begin{} or @@ End{} command.

@@ Begin{i}@Begin{i}Start italics.
@@ End{i}@End{i}End italics. 

@t[ typewriter-text @i<oblique> ]

Haha! I just read in the scribe paper that @@ Begin() and @@ End()
sections should always be properly nested.
So I just wasted some effort getting this to work:

    @@ Begin{i} italic @@ Begin{b} bold-italic @@ End{i} bold @@ End{b} normal
    @Begin{i} italic @Begin{b} bold-italic @End{i} bold @End{b} normal

@{alt/r get/ini get exec pop}But it's probably best to nest things properly anyway.
This should be considered "backup" behavior.

An interest has developed in changing the font size. Currently,
this can be hacked with explicit postscript. 
@{/fontsize 5 += /lead 3 += setfontfam /fontchange true store}Big text. 
@{/fontsize 5 -= /lead 3 -= setfontfam /fontchange true store}back to normal. 
@{/fontsize 2 *= /lead 1.5 *= setfontfam /fontchange true store}Double-size text. 
@{/fontsize .5 *= /lead .75 *= setfontfam /fontchange true store}back to normal. 
Has the lead actually been reset, or am I fooling myself?
I think I may have written a bug where the lead can only increase.
This extra text explains the purpose for this extra rambling text.
Whew. Fixed.

I just read in the scribe user manual that the same brackets should
be able to nest. This I have to fix. I had assumed that the variety
of bracket choices () [] {} <> was for the convenience of the implementation,
but I was wrong. It is for the convenience of the user, and the
implementation has a little more work to do. Currently ibis does not
correctly handle nesting of the same delimiters, and you should use 
different ones when nesting so it doesn't get confused.

@t[T @b{B @i<I @r `Roman should override all of' italics,> bold,} and typewriter] flags. 

@bye
%(stack:)= pstack(---)= currentfile flushfile


