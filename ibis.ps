%!
%(debug.ps/db5.ps)run %currentfile cvx debug

%/show { dup print (\n) print show } bind def

% mark k1 v1 .. kN vN  dicttomark  dict(N)
/dicttomark { counttomark dup dict begin 2 idiv { def } repeat pop currentdict end } def


% Composite Index  inc/dec  -
% (n.b. userdict is a composite object)
/inc { 2 copy get 1 add put } def
/dec { 2 copy get 1 sub put } def

/-= { 1 index load exch sub store } def

% Stack type is an array where element 0 contains the index of the top of the stack
% n  stack  array{n+1}:[0]=0
/stack { 1 add array dup 0 0 put } def
/top { dup 0 get get } def % S  top  a
/spop { dup top exch 0 dec } def % S  spop  a  (S{n}->S'(n-1})
/spush { % S a  spush  -  (S{n}->S'{n+1})
    dup type /stringtype eq { dup length string copy } if
    1 index 0 inc
    1 index 0 get exch put
} def
/sdrop { % S i  sdrop  -  (S{i}->removed)
    1 index 0 get      % S i c
    1 index sub 1 sub  % S i c-i-1
    dup 0 gt {
        { % S i
            1 add         % S i=i+1
            2 copy 2 copy % S i S i S i
            1 add get put % S' i
        } repeat % S' i
    }{
        pop
    } ifelse
    pop
    0 dec    % S'
} def
% a b c d e f 2 sdrop
% a b   d e f  6-2=4 -1=3
% a b d e f
%/t { 6 a b c d e f } cvlit def t 2 sdrop t ==

% output device
/dev mark
    /size [ clippath pathbbox ]
    /bounds null
dicttomark def
/savebounds { dev /bounds [ x y X Y ] put } def
/restorebounds { dev /bounds get aload pop setbounds } def
/setbounds { % x y X Y  setbounds  -
    /Y exch def /X exch def /y exch def /x exch def
} def
/setmargin { % pts  setmargin  -
    dev /size get aload pop
    4 index sub 4 1 roll 4 index sub 4 1 roll
    4 index add 4 1 roll 4 index add 4 1 roll
    setbounds pop savebounds
} def

/nextpage { showpage restorebounds eol } def

% text setting
/text mark
    /eol { /Y lead -=
        y Y lt { x Y moveto }
               { nextpage } ifelse }
    /heol { eol }
    /blank { }
    /fontchange true
    /settext {
        fontchange {
            fontfam bold 2 mul italic add get setfont
            /fontchange false store
        } if
        show
    }

    /lead 12
    /fontfam [ %  -roman- -italic- -bold- -bold-italic- 
        /Palatino-Roman findfont 10 scalefont
        /Palatino-Italic findfont 10 scalefont
        /Palatino-Bold findfont 10 scalefont
        /Palatino-BoldItalic findfont 10 scalefont
    ]
    /italic 0
    /bold 0

dicttomark def

% processing
% find takes 3 procedures a string and search-string
% and executes on_a and on_b upon the returned substrings if found
% or the not procedure if not found
/find {               % {not} {on_b} {on_a} (aXb) (X)  find  -
    search {          % n b a (b) (X) (a)
        4 1 roll pop  % n b (a) a (b)
        4 1 roll      % n (b) b (a) a
        5 -1 roll pop % (b) b (a) a
        /exec cvx 5 3 roll % (a) a exec (b) b
        /exec cvx 6 array astore cvx exec
        %exec exec
    }{                   % n b a (a_b)
        4 1 roll pop pop % (a_b) n
        exec
    } ifelse
} def
%{(n)= =}{(b)= =}{(a)= =} (pretextpost) (text) find
%(stack:)= pstack
%quit

%shift a 1-char string off of a larger string
/first { % (abc)  first  (bc) (a)
    dup 1 1 index length 1 sub getinterval exch
    0 1 getinterval
} def

% delimiter pairs
/pairs mark
    ([)(]) (<)(>) (\()(\)) ({)(}) (`)(') (:)(;)
dicttomark def

% ([)  rhs  (])
% (q)  rhs  (q)
/rhs { pairs exch 2 copy known { get }{ exch pop } ifelse } def

/nest 10 stack def
% {on_a} (])  deferal  {[{on_a} (])] nest exch spush}
% create a save-it-for-later proc
% for the not-found clause of find
/deferal {
    2 array astore
    [ exch /nest cvx /exch cvx /spush cvx ] cvx
} def

% {on_a} ([a]b)  delim  (b)
/delim {
    exch /settext cvx exch /exec cvx 3 array astore cvx exch
    first rhs       % on_a (a]b) (])
    3 copy exch pop % on_a (a]b) (]) on_a (]) 
    deferal         % on_a (a]b) (]) not    %not-clause
    {}              % on_a (a]b) (]) not on_b  %on_b clause: leave string on stack
    5 2 roll        % not on_b on_a (a]b) (])
    %(delim)= pstack()=
    find
} def

% ([arg]rem) /name  short  (rem)
/short {
    alt exch get % s d
    dup /ini get exec % s d ?
    exch /fin get % s ? {}
    [ 3 1 roll /exec cvx ] cvx exch % undo s
    %(short)= pstack()=
    delim
} def

/pending 10 stack def
% (name)  checkpending  -
/checkpending {
    (checking pending stack)=
    {
        pending 0 get -1 1 {  % (name) i
            pstack()=
            pending 1 index get  % (name) i []
            0 get 2 index
            pstack()=
            eq {  % (name) i
                stop
            } if
            pop
        } for
    } stopped {  % (name) i
        pending 1 index get 1 get  % (name) i fin-arg
        3 2 roll alt exch get /fin get exec  % i
        pending exch sdrop
    }{ Err:symbol-not-in-pending-stack } ifelse
} def
% ([name]rem)  long  (rem)
/long {
    first rhs          % (name]rem) (])
    {Err:long-form-arg-cannot-span-lines}
    {}
    {
        pstack()=
        dup length string copy
        dup alt exch get /ini get exec
        2 array astore pending exch
        pstack()=
        spush
        pending ==
    }
    5 3 roll  % {} {} {} (name]rem) (])
    find
} def

% ([name]rem)  long-end  (rem)
/long-end {
    first rhs   % (name]rem) (])
    {Err:long-form-arg-cannot-span-lines}
    {}
    {checkpending} %search pending stack and remove match
    5 3 roll  % {} {} {} (name]rem) (])
    find
} def

% str  execute  -
/execute { token { exec process }{ BAD_COMMAND } ifelse } def

% the "at" sign indicates the start of an embedded command
/sigil <40> def

/command {
    {settext} {execute} {settext} 4 3 roll
    sigil find
} def

% scan string for embedded @commands
% and call settext for other text.
/process { % str  process  -
    %(process:)= pstack()=
    dup length 0 eq { pop blank }{
        nest 0 get 0 gt {
            {command} {process} nest top aload pop % str {!} {B} {A} (X)
            exch [ exch   % str {!} {B} (X) [ {A}
                nest exch /spop cvx exch /pop cvx exch %/process cvx exch
                    /exec cvx 
            ] cvx exch  % str {!} {B} {A}' (X)
            5 4 roll exch % {!} {B} {A} str (X)
            find
        %    {process}{process} nest top aload pop  % {!} {B} {A} (X)
        %    exch [
        %        %{nest spop pop process {defered "on_a"} exec}
        %        exch nest exch /spop cvx exch /pop cvx exch /process cvx exch /exec cvx
        %        ] cvx exch % {!} {B} {A}' (X)
        %    5 4 roll exch % {!} {B} {A} str (X)
        %    find
        }{
            command
        } ifelse
    } ifelse
} def

% call process on each line
%
/src null def
/buf 200 string def
/exitflag false def
/ibis { % file|string  ibis  -
    dup type /stringtype eq { (r) file } if
    dup type /filetype ne { NOT_A_FILE } if
    /src exch def

    %pstack()=
    {
        src buf readline {process}{%process
            exit}ifelse
        heol
        exitflag { exit } if
    } loop

    showpage
} def

% @@ define the at-sign as a command to print itself
sigil { sigil settext } def


%alterations
/alt 20 dict def

% name dict  newalter  -
%
% dict should contain 2 procs
% -  ini  ?
% ?  fin  -
% where init returns an object that should be
% passed to final
/newalter {
    %install in alt dict
    2 copy alt 3 1 roll put
    %create short-form procedure
    pop [ 1 index /short cvx ] cvx def
    %create long-form
} def

/updatefont { /fontchange true store } def

/r mark
    /ini { bold 2 mul italic add /bold 0 store /italic 0 store updatefont }
    /fin { dup 2 mod /italic exch store 2 idiv /bold exch store updatefont }
dicttomark newalter

/i mark
    /ini { italic /italic 1 store updatefont }
    /fin { /italic exch store updatefont }
dicttomark newalter

/b mark
    /ini { bold /bold 1 store updatefont }
    /fin { /bold exch store updatefont }
dicttomark newalter

/Begin {
    long
} def

/End {
    long-end
} def

/default {
    text begin
    72 setmargin
    %/Palatino-Roman 10 selectfont
    %alt /r get /ini get exec pop
    %/lead 12 def
    %eol
} def

/bye {/exitflag true def} def

%print manual only if /manual is defined (eg. `gs -dmanual ibis.ps`)
%/manual where { pop }{ currentfile flushfile } ifelse 

%/i load == quit
%stepon
%traceon

default
%currentfile /ibis load debug
currentfile ibis
Text is passed to the output.
Only ragged-right, explicit linebreaks for now.

There are various ways of executing a command to change
a section of text. All commands are introduced by the @@  character,
known internally as the "sigil".

The simple command @@ i for italics, can use the short form 
with various sets of delimiters.

    @@ i[italics] @i[italics]
    @@ i(italics) @i(italics)
    @@ i<italics> @i<italics>
    @@ i{italics} @i{italics}
    @@ i `italics' @i `italics'
    @@ i :italics; @i :italics;

These last two require an extra space after the command name since
the backquote and colon are not postscript delimiters.

Incidentally, since the command name is scanned with 'token' and
executed with 'exec', it can even be a postscript procedure.
@{/oldfont currentfont def}
    @@ {/Courier 11 selectfont}text in Courier
    @{/Courier 11 selectfont}text in Courier
@{oldfont setfont}
Only "short-form" commands take a delimited argument. 
The @@ {arbitrary ps code} commands are not "short-form", 
and do not take an argument but apply directly to the current state.
But they do receive the remaining portion of the line as a string,
so a custom command may consume data from the string and yield the
remainder to be printed (it should leave a string on the stack).

Now with @b[bold].

I finally remembered what "deferal" was all about. So let's 
see if it works. It should allow bracketed commands to span
multiple lines. Like so @i[ This sentence should be all italics
despite spanning lines, in a line-oriented scanning routine. ]
And back to normal.

Long-form uses the same command names, but it is now the @i{argument}
to the @@ Begin{} or @@ End{} command.
@Begin{i}@@ Begin{i}Start italics.
@End{i}@@ End{i}End italics. 


@bye
%(stack:)= pstack(---)= currentfile flushfile


